= thread_pool

Simple thread pool with a few advanced features.

== Features

  * execution state querying
  * timeouts
  * graceful error handling
  * unit tests

== Example

  pool = ThreadPool.new :size => 2
  pool.execute{ sleep(0.01); "a" }
  pool.execute{ sleep(0.01); "b" }
  pool.execute{ sleep(0.01); "c" }
  pool.join # Should return in about 0.02 seconds... ;)
  pool.values # ["a", "b", "c"]

== Execution state

You can query the state of an execution.

  pool = ThreadPool.new :size => 2
  execution = pool.execute{ sleep(0.01); "a" }
  pool.execute{ sleep(0.01); "b" }
  pool.execute{ sleep(0.01); "c" }
  pool.join
  execution.started?   # true
  execution.finished?  # true
  execution.timed_out? # false
  execution.duration   # ~0.01
  execution.value      # "a"

== Timeouts

You can restrict how long executions are allowed to run for.

  pool = ThreadPool.new :size => 2, :timeout => 0.02, :default_value => "failed"
  pool.execute{ sleep(0.01); "a" }
  pool.execute{ sleep(0.03); "b" }
  pool.execute{ sleep(0.01); "c" }
  pool.join
  pool.executions[1].started?   # true
  pool.executions[1].finished?  # true
  pool.executions[1].timed_out? # true
  pool.executions[1].duration   # ~0.02
  pool.executions[1].value      # "failed"

== Error handling

If an execution causes an exception, it will be reraised when ThreadPool#join (or any other method that calls ThreadPool#join) is called, unless you pass <tt>:reraise => false</tt> to ThreadPool#new.  The exception is stored in ThreadPool::Execution#exception.

  pool = ThreadPool.new :size => 2, :reraise => false, :default_value => "failure"
  execution = pool.execute{ raise("busted"); "a" }
  pool.join
  execution.value # "failure"
  execution.exception # RuntimeError: busted

== Copyright

Copyright (c) 2010 Christopher J. Bottaro. See LICENSE for details.
